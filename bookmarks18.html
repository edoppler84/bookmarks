<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<title>Bookmarks</title>
<style>
body { font-family: sans-serif; margin: 0; padding: 0; background:#fafafa; }
header { background:#333; color:white; padding:10px; font-size:18px; display:flex; gap:10px; align-items:center; }
header input[type=text] { flex:1; padding:6px; }
#container { padding:10px; }
ul { list-style:none; padding:0; margin:0; }
li { background:white; margin-bottom:10px; border-radius:6px; display:flex; align-items:center; padding:6px; gap:10px; position:relative; }
.favicon { width:16px; height:16px; }
.titleArea { flex:1; cursor:pointer; }
.taginput { width:110px; }
.tag { padding:2px 5px; font-size:12px; border-radius:4px; color:white; margin-left:4px; }
.removeBtn { cursor:pointer; padding:3px 6px; border:1px solid red; border-radius:4px; color:red; margin-left:4px;}
.hiddenZone{background:#eee;padding:10px;margin-top:10px;display:none;}
.hiddenItem{background:white;margin-bottom:10px;padding:6px;border-radius:6px;display:flex;align-items:center;gap:10px;}
button{cursor:pointer;}
</style>
</head>
<body>

<header>
<input id="newLinks" placeholder="pegÃ¡ URLs acÃ¡ (enter o Procesar)" />
<button onclick="processNew()">Procesar</button>
<input id="tagFilter" placeholder="Filtrar por tags (texto parcial)" />
<button onclick="toggleHidden()">Mostrar/ocultar archivadas</button>
<button onclick="sortByDomain()">Ordenar por dominio</button>
</header>

<div id="container">
<ul id="list"></ul>
<div class="hiddenZone" id="hiddenZone"></div>
</div>
<script>
/* PARTE 2: lÃ³gica completa */

(async function(){
  // -----------------------
  // CONFIG
  // -----------------------
  const STORAGE_KEY = 'bookmarks_v3';
  const listEl = document.getElementById('list');
  const hiddenZone = document.getElementById('hiddenZone');
  const newLinks = document.getElementById('newLinks');
  const tagFilter = document.getElementById('tagFilter');
   // Replace/put your key here OR set window.YT_API_KEY before loading the page
  const YT_API_KEY = window.YT_API_KEY || 'AIzaSyBDEzDGmxVnP3QEFmbekY68yj9MNaTqtf8';

  // cascade settings
  const CASCADE_INTERVAL_MS = 300; // time between starting each fetch
  const FETCH_TIMEOUT_MS = 2000;   // timeout per request
  // -----------------------

  // UTIL
  function loadData(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      return raw ? JSON.parse(raw) : [];
    }catch(e){ return []; }
  }
  function saveData(arr){
    localStorage.setItem(STORAGE_KEY, JSON.stringify(arr));
  }
  function normalizeUrl(u){
    u = (u||'').trim();
    if(!u) return '';
    if(!/^https?:\/\//i.test(u)) u = 'https://'+u;
    return u;
  }
  function getDomain(u){
    try{ return new URL(u).hostname; } catch(e){ return u; }
  }
  function getPath(u){
    try{ return new URL(u).pathname || '/'; } catch(e){ return '/'; }
  }
  function isoNow(){ return (new Date()).toISOString(); }
  function formatDateISO(iso){
    try{
      const d = new Date(iso);
      return `${String(d.getDate()).padStart(2,'0')}/${String(d.getMonth()+1).padStart(2,'0')}/${d.getFullYear()}`;
    }catch(e){ return ''; }
  }

  // TAG helpers
  function parseTags(text){
    if(!text) return [];
    return text.split(',')
      .map(t=>t.trim())
      .filter(Boolean)
      .map(t=> t.startsWith('#') ? t.toLowerCase() : ('#'+t.toLowerCase()) );
  }
  function tagsToString(tags){
    if(!Array.isArray(tags)) return '';
    return tags.join(', ');
  }
  function hashToColor(s){
    let h=0;
    for(let i=0;i<s.length;i++){ h = s.charCodeAt(i) + ((h<<5)-h); h = h & h; }
    const hue = Math.abs(h) % 360;
    return `hsl(${hue}deg 65% 40%)`;
  }

  // normalize stored record shape (migrate old ones if needed)
  function normalizeRecord(r){
    return {
      url: r.url,
      archived: !!r.archived,
      tags: Array.isArray(r.tags) ? r.tags : parseTags(r.tags||''),
      title: r.title || null,
      created: r.created || r.timestamp || isoNow()
    };
  }

  // -----------------------
  // FETCH TITLE: YT API -> jsonlink.io -> fallback domain
  // with timeout via AbortController
  // -----------------------
  async function fetchTitleForUrl(url){
    const domain = getDomain(url).toLowerCase();

    // Abort helper
    const controller = new AbortController();
    const timeout = setTimeout(()=>controller.abort(), FETCH_TIMEOUT_MS);

    try{
      // YouTube via API if key present
      if((domain.includes('youtube.com') || domain.includes('youtu.be')) && YT_API_KEY){
        // get video id
        let vid = null;
        const m = url.match(/[?&]v=([^&]+)/);
        if(m) vid = m[1];
        else {
          const m2 = url.match(/youtu\.be\/([^?&/]+)/);
          if(m2) vid = m2[1];
        }
        if(vid){
          const api = `https://www.googleapis.com/youtube/v3/videos?part=snippet&id=${encodeURIComponent(vid)}&key=${encodeURIComponent(YT_API_KEY)}`;
          const r = await fetch(api, { signal: controller.signal });
          clearTimeout(timeout);
          if(!r.ok) throw new Error('YT '+r.status);
          const j = await r.json();
          return j.items?.[0]?.snippet?.title || getDomain(url);
        }
        // fallthrough to domain if no id
        clearTimeout(timeout);
        return getPath(url);
      }

      // jsonlink fallback
      const api2 = 'https://jsonlink.io/api/extract?url=' + encodeURIComponent(url);
      const r2 = await fetch(api2, { signal: controller.signal });
      clearTimeout(timeout);
      if(!r2.ok) throw new Error('jsonlink '+r2.status);
      const j2 = await r2.json();
      return j2.title || getPath(url);
    }catch(e){
      clearTimeout(timeout);
      // if aborted or any error -> return path placeholder (user chose option C)
      return getPath(url);
    }
  }

  // -----------------------
  // CASCADE QUEUE (A+C): process sequentially, non-blocking render
  // -----------------------
  let cascadeQueue = [];
  let cascadeRunning = false;

  function enqueueForCascade(url){
    if(!cascadeQueue.includes(url)) cascadeQueue.push(url);
    if(!cascadeRunning) runCascade();
  }

  async function runCascade(){
    cascadeRunning = true;
    while(cascadeQueue.length){
      const url = cascadeQueue.shift();
      // fetch title with timeout (handled inside fetchTitleForUrl)
      const title = await fetchTitleForUrl(url);
      if(title){
        // update stored record(s) matching url (prefer exact match)
        const arr = loadData();
        for(let i=0;i<arr.length;i++){
          if(arr[i].url === url){
            arr[i].title = title;
            // normalize tags in case old format
            arr[i] = normalizeRecord(arr[i]);
            break; // update first matching
          }
        }
        saveData(arr);
        // update DOM incrementally: find any row with same url and update its title area
        const rows = listEl.querySelectorAll('li');
        for(const r of rows){
          const idx = Number(r.dataset.index);
          const rec = normalizeRecord(loadData()[idx] || {});
          if(rec.url === url){
            const titleEl = r.querySelector('.titleArea');
            if(titleEl) titleEl.textContent = title;
          }
        }
      }
      // wait small interval before next one (cascade visual)
      await new Promise(res=>setTimeout(res, CASCADE_INTERVAL_MS));
    }
    cascadeRunning = false;
  }

  // -----------------------
  // RENDER
  // -----------------------
  function render(){
    const raw = loadData().map(normalizeRecord);
    saveData(raw); // ensure normalized storage
    listEl.innerHTML = '';

    const filterText = (tagFilter.value||'').toLowerCase();
    let visibles = 0;

    raw.forEach((rec, idx)=>{
      if(rec.archived) return;
      // filter by tag substring
      if(filterText){
        const any = (rec.tags||[]).some(t => t.toLowerCase().includes(filterText));
        if(!any) return;
      }

      visibles++;
      const li = document.createElement('li');
      li.draggable = true;
      li.dataset.index = idx;

      // checkbox for selection (not required but handy)
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.title = 'Seleccionar para acciones';
      li.appendChild(cb);

      // favicon
      const fav = document.createElement('img');
      fav.className = 'favicon';
      fav.src = 'https://www.google.com/s2/favicons?domain=' + getDomain(rec.url);
      fav.alt = '';
      li.appendChild(fav);

      // title area (placeholder: PATH if title missing)
      const titleDiv = document.createElement('div');
      titleDiv.className = 'titleArea';
      titleDiv.textContent = rec.title || getPath(rec.url);
      titleDiv.title = rec.url;
      titleDiv.addEventListener('click', ()=>{ navigator.clipboard.writeText(rec.url); alert('URL copiada'); });
      li.appendChild(titleDiv);

      // timestamp
      const ts = document.createElement('div');
      ts.className = 'timestamp';
      ts.textContent = formatDateISO(rec.created);
      li.appendChild(ts);

      // tags area (bubbles) + input
      const tagsWrap = document.createElement('div');
      tagsWrap.className = 'tags-wrap';
      // add bubbles
      (rec.tags||[]).forEach(t=>{
        const span = document.createElement('span');
        span.className = 'tag';
        span.style.background = hashToColor(t);
        span.textContent = t;
        // clicking bubble does nothing; we add small remove button inside
        const rem = document.createElement('span');
        rem.textContent = ' âœ•';
        rem.style.marginLeft = '6px';
        rem.style.cursor = 'pointer';
        rem.addEventListener('click', (ev)=>{
          ev.stopPropagation();
          const arr = loadData();
          const nrec = normalizeRecord(arr[idx] || {});
          nrec.tags = (nrec.tags||[]).filter(tt => tt !== t);
          arr[idx] = nrec;
          saveData(arr); render();
        });
        span.appendChild(rem);
        tagsWrap.appendChild(span);
      });

      // input to edit tags (on blur we save)
      const tagInput = document.createElement('input');
      tagInput.className = 'taginput';
      tagInput.value = tagsToString(rec.tags||[]);
      tagInput.placeholder = '#tag1,#tag2';
      tagInput.addEventListener('blur', ()=>{
        const arr = loadData();
        const nrec = normalizeRecord(arr[idx] || {});
        nrec.tags = parseTags(tagInput.value);
        arr[idx] = nrec;
        saveData(arr); render();
      });
      // also allow Enter in tagInput to blur
      tagInput.addEventListener('keydown', (e)=>{ if(e.key === 'Enter'){ tagInput.blur(); }});
      tagsWrap.appendChild(tagInput);
      li.appendChild(tagsWrap);

      // actions: archive, delete
      const archiveBtn = document.createElement('button');
      archiveBtn.textContent = 'ðŸ“¥';
      archiveBtn.title = 'Archivar este registro';
      archiveBtn.addEventListener('click', ()=>{
        const arr = loadData();
        if(arr[idx]) arr[idx].archived = true;
        saveData(arr); render();
      });
      li.appendChild(archiveBtn);

      const delBtn = document.createElement('button');
      delBtn.textContent = 'ðŸ—‘';
      delBtn.title = 'Eliminar registro';
      delBtn.addEventListener('click', ()=>{
        const arr = loadData(); arr.splice(idx,1); saveData(arr); render();
      });
      li.appendChild(delBtn);

      listEl.appendChild(li);

      // enqueue for title fetch if missing (cascade)
      if(!rec.title){
        enqueueForCascade(rec.url);
      }
    });

    // after rendering update stats
    const total = loadData().length;
    updateStats(total, visibles);
  }

  function updateStats(total, visibles){
    const checked = listEl.querySelectorAll('li input[type=checkbox]:checked').length;
    document.getElementById('stats').textContent = `total: ${total} / visibles: ${visibles} / marcadas: ${checked}`;
  }

  // -----------------------
  // PUBLIC ACTIONS (header buttons)
  // -----------------------
  window.processNew = function(){
    const lines = (newLinks.value||'').split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    if(!lines.length) return;
    const arr = loadData();
    const now = isoNow();
    for(const l of lines){
      const u = normalizeUrl(l);
      if(!u) continue;
      if(!arr.some(x=>x.url === u)){
        arr.push({ url: u, archived: false, tags: [], title: null, created: now });
      }
    }
    saveData(arr);
    newLinks.value = '';
    render();
  };

  window.toggleHidden = function(){
    if(hiddenZone.style.display === 'none' || !hiddenZone.style.display){
      // show archived list
      const arr = loadData().map(normalizeRecord);
      const hidden = arr.map((r,i)=> ({...r, i})).filter(x=>x.archived);
      hiddenZone.innerHTML = '';
      if(!hidden.length) hiddenZone.innerHTML = '<div class="hidden-note">No hay archivados</div>';
      else{
        hidden.forEach(h=>{
          const d = document.createElement('div');
          d.className = 'hiddenItem';
          const f = document.createElement('img'); f.className='favicon'; f.src = 'https://www.google.com/s2/favicons?domain='+getDomain(h.url);
          const s = document.createElement('div'); s.style.flex='1'; s.textContent = h.title || h.url;
          const rest = document.createElement('button'); rest.textContent='Restaurar';
          rest.addEventListener('click', ()=>{
            const arr2 = loadData(); if(arr2[h.i]) arr2[h.i].archived = false; saveData(arr2); render(); toggleHidden();
          });
          const del = document.createElement('button'); del.textContent='Eliminar';
          del.addEventListener('click', ()=>{
            const arr3 = loadData(); arr3.splice(h.i,1); saveData(arr3); render(); toggleHidden();
          });
          d.appendChild(f); d.appendChild(s); d.appendChild(rest); d.appendChild(del);
          hiddenZone.appendChild(d);
        });
      }
      hiddenZone.style.display = 'block';
    } else {
      hiddenZone.style.display = 'none';
    }
  };

  window.sortByDomain = function(){
    const arr = loadData();
    arr.sort((a,b)=> getDomain(a.url).localeCompare(getDomain(b.url)));
    saveData(arr); render();
  };

  // -----------------------
  // Drag & Drop (Trello style)
  // -----------------------
  let dragEl = null;
  listEl.addEventListener('dragstart', (e)=>{
    const li = e.target.closest('li');
    if(!li) return;
    dragEl = li;
    li.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
  });
  listEl.addEventListener('dragend', (e)=>{
    if(dragEl) dragEl.classList.remove('dragging');
    dragEl = null;
  });

  listEl.addEventListener('dragover', (e)=>{
    e.preventDefault();
    const after = getDragAfterElement(listEl, e.clientY);
    const dragging = listEl.querySelector('.dragging');
    if(!dragging) return;
    if(after == null) listEl.appendChild(dragging);
    else listEl.insertBefore(dragging, after);
  });

  function getDragAfterElement(container, y){
    const draggableElements = [...container.querySelectorAll('li:not(.dragging)')];
    return draggableElements.reduce((closest, child) => {
      const box = child.getBoundingClientRect();
      const offset = y - box.top - box.height/2;
      if(offset < 0 && offset > closest.offset){
        return { offset: offset, element: child };
      } else {
        return closest;
      }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
  }

  // when drop happens, save new order
  listEl.addEventListener('drop', (e)=>{
    e.preventDefault();
    // build new array order from DOM
    const newOrder = [];
    listEl.querySelectorAll('li').forEach(li=>{
      const idx = Number(li.dataset.index);
      const rec = normalizeRecord(loadData()[idx] || {});
      newOrder.push(rec);
    });
    saveData(newOrder);
    render();
  });

  // -----------------------
  // init
  // -----------------------
  render();

  // keyboard: press Enter in newLinks to process
  newLinks.addEventListener('keydown', (e)=>{ if(e.key === 'Enter'){ processNew(); } });

})(); // IIFE end
</script>
